##之前的檔案內容


! usr/bin/micropython

'''
led->gpio15
光敏電阻 -> gpio28
可變電阻 -> gpio26
內建溫度sensor -> adc最後1pin,共5pin
'''

from machine import Timer,ADC,Pin,PWM,RTC
import binascii
from umqtt.simple import MQTTClient
import tools,config


def do_thing(t):
    '''
    :param t:Timer的實體
    負責偵測溫度和光線
    每2秒執行1次
    '''
    conversion_factor = 3.3 / (65535)
    reading = adc.read_u16() * conversion_factor
    temperature = round(27 - (reading - 0.706)/0.001721,2) 
    print(f'溫度:{temperature}')
    mqtt.publish('SA-43/TEMPERATURE', f'{temperature}')
    blynk_mqtt.publish('ds/temperature', f'{temperature}')
    adc_value = adc_light.read_u16()
    print(f'光線:{adc_value}')
    line_state = 0 if adc_value < 13500 else 1
    print(f'光線:{line_state}')
    mqtt.publish('SA-43/LINE_LEVEL', f'{line_state}')
    blynk_mqtt.publish('ds/line_status', f'{line_state}')
    
    
def do_thing1(t):
    '''
    :param t:Timer的實體
    負責可變電阻和改變led的亮度
    '''    
    
    duty = adc1.read_u16()
    pwm.duty_u16(duty)
    light_level = round(duty/65535*10)
    print(f'可變電阻:{light_level}')
    mqtt.publish('SA-43/LED_LEVEL', f'{light_level}')
    blynk_mqtt.publish('ds/led_level', f'{light_level}')    

def main():
    global blynk_mqtt
    print(config.BLYNK_MQTT_BROKER)
    print(config.BLYNK_TEMPLATE_ID)
    print(config.BLYNK_AUTH_TOKEN)
    blynk_mqtt = MQTTClient(config.BLYNK_TEMPLATE_ID, config.BLYNK_MQTT_BROKER,user='device',password=config.BLYNK_AUTH_TOKEN)
    blynk_mqtt.connect()

if __name__ == '__main__':
    adc = ADC(4) #內建溫度
    adc1 = ADC(Pin(26)) #可變電阻
    adc_light = ADC(Pin(28)) #光敏電阻
    pwm = PWM(Pin(15),freq=50) #pwm led
    #連線internet
    try:
        tools.connect()
    except RuntimeError as e:
        print(e)
    except Exception:
        print('不知明的錯誤')
    else:
        #MQTT
        SERVER = "192.168.0.252"
        CLIENT_ID = binascii.hexlify(machine.unique_id())
        mqtt = MQTTClient(CLIENT_ID, SERVER,user='pi',password='raspberry')
        mqtt.connect()
        t1 = Timer(period=8000, mode=Timer.PERIODIC, callback=do_thing)
        t2 = Timer(period=5500, mode=Timer.PERIODIC, callback=do_thing1)   
    blynk_mqtt = None
    main()

## MQTTX 錯誤與解決方案

### 問題描述

當在終端機執行 `mqttx` 指令時出現以下錯誤：

```
[ERROR:ozone_platform_x11.cc(245)] Missing X server or $DISPLAY
[ERROR:env.cc(258)] The platform failed to initialize. Exiting.
程式記憶體區段錯誤
```

### 錯誤原因

MQTTX 是一個圖形使用者介面 (GUI) 應用程式，基於 Electron 框架開發。這類應用程式需要：
- X Server（圖形伺服器）
- $DISPLAY 環境變數設定

如果您是透過 SSH 連接到 Raspberry Pi，或者在使用無桌面環境的情況下，就會遇到這個問題。

### 解決方案

#### 方案 1：使用命令列工具（推薦）

由於您的程式碼使用的是本機 MQTT Broker (`192.168.0.252`)，建議使用 `mosquitto-clients` 套件提供的命令列工具：

**訂閱主題**（訂閱您的 Raspberry Pi Pico 發送的主題）：
```bash
# 訂閱溫度主題
mosquitto_sub -h 192.168.0.252 -t "SA-43/TEMPERATURE" -u "pi" -P "raspberry" -v

# 訂閱光線主題
mosquitto_sub -h 192.168.0.252 -t "SA-43/LINE_LEVEL" -u "pi" -P "raspberry" -v

# 訂閱 LED 亮度主題
mosquitto_sub -h 192.168.0.252 -t "SA-43/LED_LEVEL" -u "pi" -P "raspberry" -v

# 訂閱所有 SA-43 開頭的主題
mosquitto_sub -h 192.168.0.252 -t "SA-43/#" -u "pi" -P "raspberry" -v
```

**發布訊息**（測試用）：
```bash
mosquitto_pub -h 192.168.0.252 -t "SA-43/TEST" -m "測試訊息" -u "pi" -P "raspberry"
```

#### 方案 2：使用 X Forwarding（如果需要在遠端使用 GUI）

如果您透過 SSH 連接且本地有 X Server，可以使用 X Forwarding：

```bash
# 連接時使用 -X 或 -Y 參數
ssh -X username@raspberry-pi-ip

# 然後再執行 mqttx
mqttx
```

#### 方案 3：在本機直接執行（如果 Raspberry Pi 有桌面環境）

如果您的 Raspberry Pi 有安裝桌面環境（如 Raspberry Pi OS Desktop），可以在本機直接開啟終端機執行 `mqttx`。

### 建議

對於開發和測試 MQTT 應用，命令列工具 `mosquitto_pub` 和 `mosquitto_sub` 通常更適合：
- 不依賴圖形介面
- 適合自動化腳本
- 資源佔用較少
- 功能完整

### 相關指令說明

- `-h`: 指定 Broker 主機位址
- `-t`: 指定主題 (Topic)
- `-m`: 發布的訊息內容
- `-v`: 顯示詳細資訊（包含主題名稱）
- `-u`: 使用者名稱
- `-P`: 密碼
- `#`: 在主題中代表萬用字元（訂閱所有子主題）
